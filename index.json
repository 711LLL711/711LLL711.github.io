[{"content":"关于我\nHi,Klutz here~👋\nshare with you my life,skills and thoughts.\nNice to meet you.\n","permalink":"https://711lll711.github.io/about/","summary":"关于我 Hi,Klutz here~👋 share with you my life,skills","title":"🙋🏻‍♂️关于"},{"content":"响应的格式、数据类型设计 响应的数据全部存在data字段中，可以设置makereponse函数生成响应 设计合适的结构体 数据库进阶操作 外键、主键、联合主键\n主键：唯一标识某一行 联合主键：多个列的值联合标识某一行\n外键：将一个表的列与另一个表的列相关联，一个表中的外键值必须在另一个表中存在。用于实现一对多和多对多的查询 CREATE TABLE Orders ( OrderID INT PRIMARY KEY, CustomerID INT, FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID) ); //连接多个表查询 //根据 order找出customer的country var country Country if err := global.GVA_DB. Joins(\u0026#34;JOIN customers ON orders.customer_id = customers.id\u0026#34;). Joins(\u0026#34;JOIN countries ON customers.country_id = countries.id\u0026#34;). Where(\u0026#34;orders.id = ?\u0026#34;, 1). Select(\u0026#34;countries.name\u0026#34;). First(\u0026amp;country).Error; err != nil { // 处理查询错误 } else { // 使用 country 数据 } //joins语法 db.Joins(\u0026#34;JOIN table_name ON condition\u0026#34;) //condition是SQL的条件语句 使用gorm创建、查询、更新、删除\n如果涉及多个表同时查询写入，采用事务，方便回滚\n预加载，它在一次查询中获取了关联的数据，而不是为每个主对象执行额外的查询。 // 开始事务 tx := db.Begin() // 执行事务操作 if err := tx.Create(\u0026amp;User{Name: \u0026#34;Alice\u0026#34;}).Error; err != nil { // 发生错误，回滚事务 tx.Rollback() // 处理事务错误 } else { // 事务操作成功，提交事务 tx.Commit() } 自动迁移表格automigrate\n用于确保数据库中的表格结构与应用程序中的数据模型一致。 好用的库 copier copier.Copy(\u0026amp;employee, \u0026amp;user) 就是将user对象中的字段赋值到employee的同名字段中。如果目标对象中没有同名的字段，则该字段被忽略。\n比如创建群组功能，不需要单个字段赋值给group结构，只需要用copier把groupreq的字段传递给group即可\nzap 日志库\n从标准日志库log到zap 创建 Logger实例 使用 Zap 创建一个 Logger 实例，Logger 用于记录日志消息。通常你会在应用程序的初始化代码中创建 Logger。\nlogger, err := zap.NewProduction()// NewProduction() 和 NewDevelopment() NewExample() 三种模式 if err != nil { // 处理错误 } defer logger.Sync() // 在程序退出时释放资源 日志配置\nzap.NewDevelopmentConfig() 是 Zap 日志库提供的一个函数，用于创建一个适用于开发和调试环境的日志配置。\nLevel: 默认设置为 Debug，允许记录所有日志级别，包括 Info、Debug、Warn、Error、 DPanic 和 Panic。\nEncoding: 默认使用 JSON 编码格式，以便日志可以轻松地被其他工具解析。\nOutput Paths: 默认将日志输出到标准错误流（stderr），这在开发环境中通常是合适的。\nError Output Paths: 默认将错误级别的日志（Error、DPanic 和 Panic）也输出到标准错误流。\nEncoder Config: 编码器配置允许对 JSON 编码进行一些自定义设置，如时间格式。\n日志级别 Info(), Debug(), Warn(), Error(), Fatal()\u0026hellip;\n结构化日志\nlogger.Info(\u0026#34;User login\u0026#34;, zap.String(\u0026#34;username\u0026#34;, \u0026#34;john_doe\u0026#34;), zap.Int(\u0026#34;status_code\u0026#34;, 200)) 设置全局字段 logger = logger.With(zap.String(\u0026#34;app_name\u0026#34;, \u0026#34;MyApp\u0026#34;)) 设置日志输出的位置 // 创建一个输出到文件的 WriteSyncer fileWriter := zapcore.AddSync(file) // 创建一个 core fileCore := zapcore.NewCore( zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()), // 或者使用其他编码器 fileWriter, zap.DebugLevel, // 设置日志级别 ) // 创建 Logger logger := zap.New(fileCore, zap.AddCaller()) defer logger.Sync() mapstructure将map映射到结构体，viper解析配置文件\n\u0026ndash;无需自己写解析函数 # config.yaml Mysql: host: \u0026#34;localhost\u0026#34; port: \u0026#34;3306\u0026#34; user: \u0026#34;用户名\u0026#34; password: \u0026#34;数据库密码\u0026#34; charset: \u0026#34;utf8\u0026#34; database: \u0026#34;TeamToDo\u0026#34; type MySQLConfig struct { Host string `mapstructure:\u0026#34;host\u0026#34;` Port string `mapstructure:\u0026#34;port\u0026#34;` User string `mapstructure:\u0026#34;user\u0026#34;` Password string `mapstructure:\u0026#34;password\u0026#34;` Charset string `mapstructure:\u0026#34;charset\u0026#34;` Database string `mapstructure:\u0026#34;database\u0026#34;` } // 从文件加载配置 viper.SetConfigFile(\u0026#34;config.yaml\u0026#34;)//设置配置文件 err := viper.ReadInConfig() if err != nil { log.Fatalf(\u0026#34;读取配置文件失败: %v\u0026#34;, err) } // 初始化一个空的 Config 结构体 var config Config // 使用 mapstructure 将配置文件加载到结构体中 err = viper.Unmarshal(\u0026amp;config, viper.DecoderConfigOption(mapstructure.NewDecoderConfigOption()))//解码器 if err != nil { log.Fatalf(\u0026#34;解析配置文件失败: %v\u0026#34;, err) } // 打印配置信息 fmt.Printf(\u0026#34;Mysql Host: %s\\n\u0026#34;, config.Mysql.Host) rand生成随机数 rand.New(rand.NewSource(time.Now().UnixNano())).Intn(1000000) rand.New()//创建随机数生成器 rand.NewSource()//创建随机数种子 Intn()//随机数范围 jwt使用 创建jwt //创建claims claims := jwt.MapClaims{ \u0026#34;userID\u0026#34;: id, \u0026#34;exp\u0026#34;: time.Now().Add(time.Second * time.Duration(global.Server.JWT.ExpireTime)).Unix(), } //创建token token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) //or token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{ \u0026#34;userID\u0026#34;: id, \u0026#34;exp\u0026#34;: time.Now().Add(time.Second * time.Duration(global.Server.JWT.ExpireTime)).Unix(), }) //使用密钥签名 tokenString, err := token.SignedString([]byte(global.Server.JWT.Key)) //从头部中获取token auth := c.GetHeader(\u0026#34;Authorization\u0026#34;) tokenString := auth[len(\u0026#34;Bearer \u0026#34;):]//切片 //解析token //允许你将特定声明解析到自定义的结构体中。 token, err := jwt.ParseWithClaims(tokenString, \u0026amp;jwt.MapClaims{}, func(token *jwt.Token) (interface{}, error) { return []byte(jwtKey), nil }) //获取基本claims token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) { return []byte(global.Server.JWT.Key), nil }) claims, ok := token.Claims.(*jwt.MapClaims)//claims转换 token.vaild//token是否有效 strconv\n提供字符串与其他数据类型的互转\ngomail用于发送电子邮件\nregexp正则表达式\n//创建正则表达式对象 pattern := `^1[3456789]\\d{9}$` reg := regexp.MustCompile(pattern)//编译正则表达式 //匹配字符串 reg.MatchString(phone) //查找字符串 reg.FindString(phone) //查找字符串中所有符合条件的子串 reg.FindAllString(phone, -1) //替换字符串 reg.ReplaceAllString(phone, \u0026#34;****\u0026#34;) 其他 iota\niota 是 Go 语言中的一个常量生成器，它用于在常量声明中生成连续的整数值。 iota 从 0 开始，每次在常量声明中使用它时都会自增 1。一般用于枚举常量，简化了常量的定义，使代码更具可读性。 const ( Sunday = iota // 0 Monday // 1 Tuesday // 2 Wednesday // 3 Thursday // 4 Friday // 5 Saturday // 6 ) ","permalink":"https://711lll711.github.io/posts/tech/team_reflection/","summary":"响应的格式、数据类型设计 响应的","title":"team_todo项目复盘"},{"content":"关于主题 Freedom.What do you want?Noah可以说是Allie价值观的启蒙者，或者说唤醒了Allie深藏于内心追求自我欲望的小人。初识时Allie是个发着光的小女孩，家境优渥，追求者无数，然而被迫学着父母给她安排的课，从不叩问内心自己想要什么。Noah带她体验了自由的生活，可以躺在马路上看着红绿灯变换。Allie说“如果有车来了怎么办？”Noah说\u0026quot;Then we die.Just trust.\u0026ldquo;他们在一起过的是她从未经历过的随性的生活。她不再背着那么多包袱，那么多考虑，just do what she wants.\n关于逃婚 婚礼前夕Allie得知Noah修缮好了当初承诺的房子，她决定看看，去更贴近自己的内心。让许多人接受不了的是Allie背叛了未婚夫劈腿，但我恰恰觉得这是主题生动的体现。她把自己的心放到了比道德、未婚夫、父母的期待更高的优先级上。也许这样的她让自己都感到惊讶，也许正是因为此坚定了她选择Noah的决心。在爱与合适面前，她遵从了自己的内心。\n关于意象 战争 有人觉得突然插入一个参军打仗很突兀，这其实是双方人生的转折点。Allie在照顾伤员时认识了Lon，又走近了父母期待的门当户对的婚姻。Noah在战争中失去了父亲、朋友，房子是他唯一的寄托，然而在修葺过程中他偶遇了Allie和未婚夫，内心唯一的希望也破灭。他的人生一片灰暗。如果说17岁时是Noah教会了Allie开启自由的人生，那么战争后的Allie则给了Noah重生的希望。 绘画\n绘画是自由的象征。绘画是Allie告诉Noah的她喜欢的东西。然而在Allie的所有课程中却没有绘画课。绘画是对自由的追求的小小的种子。结婚前，Allie对Lon说，我很久没画画了。我喜欢画画。Lon说“wow I did not know that.then you can paint”他不懂的是，绘画是只属于Allie和Lon的关于自由的秘密。在房子里，Allie沿着箭头，看到了Noah为她准备的绘画工具。 变与不变\nAllie在船上对Noah说\u0026quot;You are different.Just the way you look.Everything\u0026rdquo;.Noah说\u0026quot;you are different too.But in a good way.\u0026quot; 表面上看，Allie离开了Noah有了更好的生活，而Noah反而过的很差。但其实，Noah一直坚持了他想做的事，Allie却似乎对生活做出了妥协。 大雨来临，Allie赶紧遮住头，Noah则大笑，Allie也马上大笑起来，就像17岁她看见车来了马上跳起然后一起大笑。这时她意识到离开Noah时自己似乎变回了那个no freedom的女孩。 \u003c!DOCTYPE html\u003e\r","permalink":"https://711lll711.github.io/posts/read/thenotebook/","summary":"关于主题 Freedom.What do you want?Noa","title":"恋恋笔记本"},{"content":"测试相册功能 \u003c!DOCTYPE html\u003e\rtest\r香克斯\r香克斯\r","permalink":"https://711lll711.github.io/posts/life/life/","summary":"测试相册功能 \u003c!DOCTYPE html\u003e test 香克斯 香克斯","title":"Life"},{"content":"","permalink":"https://711lll711.github.io/posts/read/read/","summary":"","title":"Read"},{"content":"\rKlutz\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r👉友链格式\r名称： Klutz\u0026rsquo;s Blog 网址： https://github.com/711lll711.github.io 图标： https://github.com/711lll711.github.io/img/avatar.png 描述： 一个记录技术、阅读、生活的博客 ","permalink":"https://711lll711.github.io/links/","summary":"Klutz\u0026#39;s Blog 一个记录技术、阅读、生活的","title":"🤝友链"}]