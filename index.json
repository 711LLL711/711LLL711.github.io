[{"content":"自动倍速刷课 智慧树禁止倍速，刷课中途还会跳出一些检测题让你不能一边开着一边摸鱼！可自行了解ocs网课助手。 ocs网课助手\n复制粘贴 背景 选了一个线上公选课，要在智慧树听课，平时分包括网上看视频的天数、问答数什么的，问答倒比较好抄，直接cv就行了，结果js复制粘贴被禁用了orz\n禁止原因 js设置了禁用复制粘贴 js脚本解除复制粘贴限制 在油猴中新建脚本，把这段代码复制上去保存就好！\n// ==UserScript== // @name Disable Copy and Paste Restrictions // @namespace https://711LLL711.github.io // @version 1.0 // @description Disable copy, paste, and context menu restrictions on zhihuishu.com // @author Klutz // @match https://qah5.zhihuishu.com/* // @grant none // ==/UserScript== (function() { \u0026#39;use strict\u0026#39;; setTimeout(function(){ // 允许选择文本 document.onselectstart = true; // 允许复制剪切粘贴和鼠标右键菜单操作 document.oncopy = true; document.oncut = true; document.onpaste = true; document.oncontextmenu = true; }, 1000); })(); 当然，你也可以每次F12在console中手动输入\ndocument.onselectstart = true; document.oncopy = true; document.oncut = true; document.onpaste = true; document.oncontextmenu = true; ","permalink":"https://711lll711.github.io/posts/tech/zhihuishu/","summary":"自动倍速刷课 智慧树禁止倍速，刷","title":"智慧树解除复制粘贴、自动刷课"},{"content":"叙述与节奏 以老rose回忆的方式来讲述整个故事 首先是第一视角有代入感 迟暮之年的rose回忆少女时的邂逅、生死抉择，强烈的反差，美人迟暮，斯人已逝，生死茫茫，宏伟的永不沉没的泰坦尼克号已成残骸。 讲述不仅有rose还有船长等听众，从最初的不太相信rose身份到急切地追问后来发生了什么，在恰当的时间段切到现实，把故事分节，调节节奏，吸引兴趣。 两根本不会交错的线 故事的开始介绍了rose和jack上船的理由。rose是贵族少女，乘船到美国远嫁；jack是浪迹天涯的画家，靠赌博赢得了船票。两人身份地位相差悬殊，向两根永不交错的平行线，但泰坦尼克号称为了他们人生的交点。船沉以后，却阴阳两隔，永不能再见。 泰坦尼克号\u0026ndash;社会的缩影 泰坦尼克号以舱位论阶层，一如社会的三六九等。 富人住在奢华的房间里，举行奢华的宴会，女人浮于表面的社交，男人夸夸其谈政治经济。财富是通向这个阶层的通行证。但又不全是。胖太太说，要让他们觉得你有钱，他们接纳你。富人阶级极尽奢华、享乐、轻浮、势利。穷人住在逼仄的房间里，却快乐、单纯。 导演詹姆斯卡梅隆隐喻的不仅仅是当时欧洲某些国家的狂妄固执，也隐喻人类现在社会制度的缺陷。 船沉以后\u0026ndash; 富人拥有财富和权利，恣意妄为，结果让全社会如同一艘巨轮一样无可避免地向冰山高速驶去。穷人意识到危险惊恐的求生，富人还活在奢华的泡沫中不相信危险的到来。底层百姓在睡梦中走向死亡，而富人仍能找到办法脱身。 主题 文学的母题总是相通的。生与死、人性、自由、社会、爱情在影片中都得到了很好的诠释。\n如何面对死亡 生死抉择，是个很沉重的话题。泰坦尼克号上，所有人都没做好这个准备。 必定赴死时，你怎么做？ 四个乐手即使没有人听他们演奏，即使船将沉没，仍坚持演奏，艺术不能阻止沉没，但可以给人平和和勇气，是渺小的人类在灾难面前不屈的抗争。 可以逃生时，你怎么做？ rose，jack，carl都放弃过上救生艇的机会。\nrose第一次放弃上船的机会，是要返回救被囚禁的jack。在求生和爱情面前，爱情赢了。 rose和jack一起往上爬时，看到水中哭泣的小孩，决定过去救他。在求生和救人面前，救人赢了。 jack和carl目送rose上救生艇时，那是两个男人对她的告别，是爱与责任。\nrose跳下jack愿意和他一起，在求生和爱情面前，爱情还是赢了。 胖太太提出要返回救人上船，求生和道德面前，道德赢了。 面对绝望时，你怎么做？ jack两次点燃了rose的生命之火。 第一次是问rose:do you love him?在rose说不要来找她时，他说你的生命之火会慢慢熄灭。 第二次是他们两个人困在浮板上，jack让rose答应不要放弃。凭着坚强的意志力，rose获救了。 人性复杂 越是在巨大灾难面前越能看到人性。有爱、责任、坚强、勇敢；也有自私、怯懦。 自由 我愿意把rose和jack之间理解成自由的救赎与爱情的结合。 意象 海洋之心 \u0026ndash;未完待续惹🤪⛴️🦢\n","permalink":"https://711lll711.github.io/posts/read/titanic/","summary":"叙述与节奏 以老rose回忆的方","title":"泰坦尼克号"},{"content":" chkconfig -\u0026gt;sysv-rc-conf\n没有chkconfig E: Unable to locate package sysv-rc-conf 配置镜像源 sudo vim /etc/apt/sources.list deb http://archive.ubuntu.com/ubuntu/ trusty main universe restricted multiverse # 更新安装源 sudo apt-get update # 安装sysv-rc-conf sudo apt-get install sysv-rc-conf warning! Warning: apt-key is deprecated. Manage keyring files in trusted.gpg.d instead (see apt-key(8)).\nsysv-rc-conf : Depends: sysv-rc but it is not going to be installed\nErrors were encountered while processing: /var/cache/apt/archives/sysv-rc_2.88dsf-41ubuntu6_all.deb E: Sub-process /usr/bin/dpkg returned an error code (1)\n在askubuntu得知，sysv-rc-conf已经被systemd替换 sysv被systemd替换\n# 查看版本 systemd --version ","permalink":"https://711lll711.github.io/posts/tech/chkconfig/","summary":"chkconfig -\u0026gt;sysv-rc-conf 没有chkconfig E: Unable","title":"ubuntu22.04如何使用chkconfig命令"},{"content":"下载vmware workstation并安装ubuntu 下载好vm和ubuntu iso文件，一直下一步就好啦~ 装好ubuntu后用apt下两个必要工具，vim用来编辑文件，net-tools用来查看网络状态\nsudo apt install vim sudo apt install net-tools NAT联网，固定静态ip 概念简介 ip: 用来标识网络中的一台主机，ip地址由32位二进制数组成，分为网络号和主机号两部分，网络号用来标识网络，主机号用来标识主机。ip地址分为公网ip和私网ip，公网ip是可以直接访问的，私网ip只能在局域网内访问。ip地址分为ipv4和ipv6。 子网掩码： 用来标识ip地址中网络号和主机号的分界线，子网掩码也是32位二进制数，子网掩码中的网络号部分全为1，主机号部分全为0。子网掩码和ip地址进行与运算，得到的结果就是网络号。子网掩码的作用是用来判断两台主机是否在同一个局域网内，如果两台主机的ip地址与子网掩码进行与运算，得到的结果相同，那么这两台主机就在同一个局域网内，可以直接通信，否则就需要通过路由器进行通信。 网关： 网关是一台主机，它的ip地址是局域网内的一个ip地址，顾名思义就是公网与局域网之间的大门~网关的作用是将局域网内的数据转发到公网上，或者将公网上的数据转发到局域网内。网关的ip地址一般是局域网内的第一个ip地址，也就是网络号不变，主机号为0的ip地址。 DNS： DNS是一种域名解析服务，它的作用是将域名解析成ip地址。 NAT联网 什么是NAT？\n原理参考韩顺平linux\n固定静态ip 在我们没有设置静态ip之前，默认是使用DHCP自动分配ip，也是可以上网的，但是每次重启虚拟机，ip地址都会变化，这样就不方便了。所以我们需要设置静态ip。\n方法1：图形化界面 打开设置，选择网络，齿轮，选择Wired Settings 点击齿轮，选择IPv4，选择Manual，填入ip地址，子网掩码，网关，DNS\n怎么确定这些值？ 在windows主机上打开cmd，输入ipconfig，我们看的是vmnet8的ip地址，子网掩码，网关，DNS 在ubuntu填入值： ip:直接固定为DHCP分配的ip地址 子网掩码：与vmnet8保持一致 网关：vmnet8的ip地址 DNS：8.8.8.8就行 点击Apply，然后重启网络服务。 方法2：命令行 按照方法1同样的数值配置修改相关参数\n修改网络配置文件 //su进入根目录后 vim /etc/netplan/01-network-manager-all.yaml //修改文件内容如下 network: version: 2 renderer: NetworkManager ethernets: ens33: dhcp4: no # 取消自动分配ip addresses: [192.168.1.10/24] # 你的虚拟机的ipv4地址/子网掩码 routes: - to: 0.0.0.0/0 via: 192.168.0.1 # 这里是你的网关地址 metric: 100 nameservers: addresses: [8.8.8.8, 8.8.4.4] #DNS地址 重启网络服务，查看ip sudo netplan apply sudo systemctl restart NetworkManager ifconfig 踩坑记录 su root显示 authentication failure 原因： 这是因为在Ubuntu中，默认情况下，root 用户是被禁用的，不允许直接登录。相反，Ubuntu鼓励使用 sudo 命令以普通用户的身份来执行需要超级用户权限的操作。\n解决方法：\n在普通用户的帐户下使用 sudo 命令来执行需要超级用户权限的操作。 sudo command_to_run_as_root 设置root密码 sudo passwd root 修改yaml后warning 有的教程写的是gateway4:\u0026hellip;, 但提示warning: gateway4 has been deprecated, use default routes instead. See the \u0026lsquo;Default routes\u0026rsquo; section of the documentation for more details. 所以修改为\nroutes: - to: 0.0.0.0/0* via: 192.168.0.1 # 这里是你的网关地址 metric: 100 解释：\nto: 0.0.0.0/0 表示所有非本地流量都将通过 via 字段指定的网关（你的网关地址）进行路由。metric 字段是一个可选的参数，用于指定路由的优先级，通常可以设置为100或更高。\n","permalink":"https://711lll711.github.io/posts/tech/ubuntusetup/","summary":"下载vmware worksta","title":"vmware安装ubuntu并配置静态ip"},{"content":"关于我\nHi,Klutz here~👋\nshare with you my life,skills and thoughts.\nNice to meet you.\n","permalink":"https://711lll711.github.io/about/","summary":"关于我 Hi,Klutz here~👋 share with you my life,skills","title":"🙋🏻‍♂️关于"},{"content":"响应的格式、数据类型设计 响应的数据全部存在data字段中，可以设置makereponse函数生成响应 设计合适的结构体 数据库进阶操作 外键、主键、联合主键\n主键：唯一标识某一行 联合主键：多个列的值联合标识某一行\n外键：将一个表的列与另一个表的列相关联，一个表中的外键值必须在另一个表中存在。用于实现一对多和多对多的查询 CREATE TABLE Orders ( OrderID INT PRIMARY KEY, CustomerID INT, FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID) ); //连接多个表查询 //根据 order找出customer的country var country Country if err := global.GVA_DB. Joins(\u0026#34;JOIN customers ON orders.customer_id = customers.id\u0026#34;). Joins(\u0026#34;JOIN countries ON customers.country_id = countries.id\u0026#34;). Where(\u0026#34;orders.id = ?\u0026#34;, 1). Select(\u0026#34;countries.name\u0026#34;). First(\u0026amp;country).Error; err != nil { // 处理查询错误 } else { // 使用 country 数据 } //joins语法 db.Joins(\u0026#34;JOIN table_name ON condition\u0026#34;) //condition是SQL的条件语句 使用gorm创建、查询、更新、删除\n如果涉及多个表同时查询写入，采用事务，方便回滚\n预加载，它在一次查询中获取了关联的数据，而不是为每个主对象执行额外的查询。 // 开始事务 tx := db.Begin() // 执行事务操作 if err := tx.Create(\u0026amp;User{Name: \u0026#34;Alice\u0026#34;}).Error; err != nil { // 发生错误，回滚事务 tx.Rollback() // 处理事务错误 } else { // 事务操作成功，提交事务 tx.Commit() } 自动迁移表格automigrate\n用于确保数据库中的表格结构与应用程序中的数据模型一致。 好用的库 copier copier.Copy(\u0026amp;employee, \u0026amp;user) 就是将user对象中的字段赋值到employee的同名字段中。如果目标对象中没有同名的字段，则该字段被忽略。\n比如创建群组功能，不需要单个字段赋值给group结构，只需要用copier把groupreq的字段传递给group即可\nzap 日志库\n从标准日志库log到zap 创建 Logger实例 使用 Zap 创建一个 Logger 实例，Logger 用于记录日志消息。通常你会在应用程序的初始化代码中创建 Logger。\nlogger, err := zap.NewProduction()// NewProduction() 和 NewDevelopment() NewExample() 三种模式 if err != nil { // 处理错误 } defer logger.Sync() // 在程序退出时释放资源 日志配置\nzap.NewDevelopmentConfig() 是 Zap 日志库提供的一个函数，用于创建一个适用于开发和调试环境的日志配置。\nLevel: 默认设置为 Debug，允许记录所有日志级别，包括 Info、Debug、Warn、Error、 DPanic 和 Panic。\nEncoding: 默认使用 JSON 编码格式，以便日志可以轻松地被其他工具解析。\nOutput Paths: 默认将日志输出到标准错误流（stderr），这在开发环境中通常是合适的。\nError Output Paths: 默认将错误级别的日志（Error、DPanic 和 Panic）也输出到标准错误流。\nEncoder Config: 编码器配置允许对 JSON 编码进行一些自定义设置，如时间格式。\n日志级别 Info(), Debug(), Warn(), Error(), Fatal()\u0026hellip;\n结构化日志\nlogger.Info(\u0026#34;User login\u0026#34;, zap.String(\u0026#34;username\u0026#34;, \u0026#34;john_doe\u0026#34;), zap.Int(\u0026#34;status_code\u0026#34;, 200)) 设置全局字段 logger = logger.With(zap.String(\u0026#34;app_name\u0026#34;, \u0026#34;MyApp\u0026#34;)) 设置日志输出的位置 // 创建一个输出到文件的 WriteSyncer fileWriter := zapcore.AddSync(file) // 创建一个 core fileCore := zapcore.NewCore( zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()), // 或者使用其他编码器 fileWriter, zap.DebugLevel, // 设置日志级别 ) // 创建 Logger logger := zap.New(fileCore, zap.AddCaller()) defer logger.Sync() mapstructure将map映射到结构体，viper解析配置文件\n\u0026ndash;无需自己写解析函数 # config.yaml Mysql: host: \u0026#34;localhost\u0026#34; port: \u0026#34;3306\u0026#34; user: \u0026#34;用户名\u0026#34; password: \u0026#34;数据库密码\u0026#34; charset: \u0026#34;utf8\u0026#34; database: \u0026#34;TeamToDo\u0026#34; type MySQLConfig struct { Host string `mapstructure:\u0026#34;host\u0026#34;` Port string `mapstructure:\u0026#34;port\u0026#34;` User string `mapstructure:\u0026#34;user\u0026#34;` Password string `mapstructure:\u0026#34;password\u0026#34;` Charset string `mapstructure:\u0026#34;charset\u0026#34;` Database string `mapstructure:\u0026#34;database\u0026#34;` } // 从文件加载配置 viper.SetConfigFile(\u0026#34;config.yaml\u0026#34;)//设置配置文件 err := viper.ReadInConfig() if err != nil { log.Fatalf(\u0026#34;读取配置文件失败: %v\u0026#34;, err) } // 初始化一个空的 Config 结构体 var config Config // 使用 mapstructure 将配置文件加载到结构体中 err = viper.Unmarshal(\u0026amp;config, viper.DecoderConfigOption(mapstructure.NewDecoderConfigOption()))//解码器 if err != nil { log.Fatalf(\u0026#34;解析配置文件失败: %v\u0026#34;, err) } // 打印配置信息 fmt.Printf(\u0026#34;Mysql Host: %s\\n\u0026#34;, config.Mysql.Host) rand生成随机数 rand.New(rand.NewSource(time.Now().UnixNano())).Intn(1000000) rand.New()//创建随机数生成器 rand.NewSource()//创建随机数种子 Intn()//随机数范围 jwt使用 创建jwt //创建claims claims := jwt.MapClaims{ \u0026#34;userID\u0026#34;: id, \u0026#34;exp\u0026#34;: time.Now().Add(time.Second * time.Duration(global.Server.JWT.ExpireTime)).Unix(), } //创建token token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) //or token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{ \u0026#34;userID\u0026#34;: id, \u0026#34;exp\u0026#34;: time.Now().Add(time.Second * time.Duration(global.Server.JWT.ExpireTime)).Unix(), }) //使用密钥签名 tokenString, err := token.SignedString([]byte(global.Server.JWT.Key)) //从头部中获取token auth := c.GetHeader(\u0026#34;Authorization\u0026#34;) tokenString := auth[len(\u0026#34;Bearer \u0026#34;):]//切片 //解析token //允许你将特定声明解析到自定义的结构体中。 token, err := jwt.ParseWithClaims(tokenString, \u0026amp;jwt.MapClaims{}, func(token *jwt.Token) (interface{}, error) { return []byte(jwtKey), nil }) //获取基本claims token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) { return []byte(global.Server.JWT.Key), nil }) claims, ok := token.Claims.(*jwt.MapClaims)//claims转换 token.vaild//token是否有效 strconv\n提供字符串与其他数据类型的互转\ngomail用于发送电子邮件\nregexp正则表达式\n//创建正则表达式对象 pattern := `^1[3456789]\\d{9}$` reg := regexp.MustCompile(pattern)//编译正则表达式 //匹配字符串 reg.MatchString(phone) //查找字符串 reg.FindString(phone) //查找字符串中所有符合条件的子串 reg.FindAllString(phone, -1) //替换字符串 reg.ReplaceAllString(phone, \u0026#34;****\u0026#34;) 其他 iota\niota 是 Go 语言中的一个常量生成器，它用于在常量声明中生成连续的整数值。 iota 从 0 开始，每次在常量声明中使用它时都会自增 1。一般用于枚举常量，简化了常量的定义，使代码更具可读性。 const ( Sunday = iota // 0 Monday // 1 Tuesday // 2 Wednesday // 3 Thursday // 4 Friday // 5 Saturday // 6 ) git之rebase 什么是rebase\nRebase命令是一个在另一个分支基础之上重新应用提交的过程，用于把一个分支的修改合并到当前分支。使用rebase命令可以保持提交历史的整洁和线性，但是也可能导致冲突和提交历史的改变。\nrebase和merge的区别\n合并历史的方式：\nMerge（合并）： 在合并操作中，Git 会创建一个新的合并提交（merge commit），该提交将两个分支的历史记录合并在一起。这个合并提交拥有两个父提交，分别指向被合并的分支的最新提交。这种方法会保留分支的整体历史记录，但可能会导致历史记录中出现复杂的合并提交。\nRebase（变基）： 在变基操作中，Git 会将一系列提交从一个分支复制到另一个分支，并以线性的方式应用这些提交，就好像它们是在目标分支上连续提交的一样。这种方式会改写提交历史，不会创建合并提交，使得提交历史看起来更加干净和线性。\n提交历史的清晰度：\nMerge： Merge 操作会保留每个分支的独立历史，包括分支的起始点和合并点。这可以让您清楚地看到分支是如何演化的，但可能会导致历史记录中出现许多合并提交，使得历史较为复杂。\nRebase： Rebase 操作会使提交历史更加线性和干净，因为它将提交直接应用在目标分支的顶部，看起来就像它们是按顺序提交的。这种方式通常让提交历史更容易理解，但也会删除分支的独立历史。\n合并冲突的处理：\nMerge： 如果在合并操作中出现冲突，Git 会创建一个合并提交，您需要解决冲突并提交该合并提交。这个过程相对较为简单，因为您只需要处理一次冲突。\nRebase： 如果在变基操作中出现冲突，Git 会在每个提交上都可能出现冲突，您需要逐一解决这些冲突。这可能会更复杂，因为您需要处理多个提交的冲突。\n分支历史的保留与整理：\nMerge： Merge 会保留分支的整个历史记录，包括分支的起始点和合并点。这对于跟踪分支的演变非常有用，但可能导致历史记录复杂。\nRebase： Rebase 会整理提交历史，将一系列提交线性化，并将它们应用在目标分支的顶部。这可以保持提交历史的整洁，但会删除分支的独立历史。\n参考 csdn freecodecamp\n","permalink":"https://711lll711.github.io/posts/tech/team_reflection/","summary":"响应的格式、数据类型设计 响应的","title":"team_todo项目复盘"},{"content":"关于主题 Freedom.What do you want?Noah可以说是Allie价值观的启蒙者，或者说唤醒了Allie深藏于内心追求自我欲望的小人。初识时Allie是个发着光的小女孩，家境优渥，追求者无数，然而被迫学着父母给她安排的课，从不叩问内心自己想要什么。Noah带她体验了自由的生活，可以躺在马路上看着红绿灯变换。Allie说“如果有车来了怎么办？”Noah说\u0026quot;Then we die.Just trust.\u0026ldquo;他们在一起过的是她从未经历过的随性的生活。她不再背着那么多包袱，那么多考虑，just do what she wants.\n关于逃婚 婚礼前夕Allie得知Noah修缮好了当初承诺的房子，她决定看看，去更贴近自己的内心。让许多人接受不了的是Allie背叛了未婚夫劈腿，但我恰恰觉得这是主题生动的体现。她把自己的心放到了比道德、未婚夫、父母的期待更高的优先级上。也许这样的她让自己都感到惊讶，也许正是因为此坚定了她选择Noah的决心。在爱与合适面前，她遵从了自己的内心。\n关于意象 战争 有人觉得突然插入一个参军打仗很突兀，这其实是双方人生的转折点。Allie在照顾伤员时认识了Lon，又走近了父母期待的门当户对的婚姻。Noah在战争中失去了父亲、朋友，房子是他唯一的寄托，然而在修葺过程中他偶遇了Allie和未婚夫，内心唯一的希望也破灭。他的人生一片灰暗。如果说17岁时是Noah教会了Allie开启自由的人生，那么战争后的Allie则给了Noah重生的希望。 绘画\n绘画是自由的象征。绘画是Allie告诉Noah的她喜欢的东西。然而在Allie的所有课程中却没有绘画课。绘画是对自由的追求的小小的种子。结婚前，Allie对Lon说，我很久没画画了。我喜欢画画。Lon说“wow I did not know that.then you can paint”他不懂的是，绘画是只属于Allie和Lon的关于自由的秘密。在房子里，Allie沿着箭头，看到了Noah为她准备的绘画工具。 变与不变\nAllie在船上对Noah说\u0026quot;You are different.Just the way you look.Everything\u0026rdquo;.Noah说\u0026quot;you are different too.But in a good way.\u0026quot; 表面上看，Allie离开了Noah有了更好的生活，而Noah反而过的很差。但其实，Noah一直坚持了他想做的事，Allie却似乎对生活做出了妥协。 大雨来临，Allie赶紧遮住头，Noah则大笑，Allie也马上大笑起来，就像17岁她看见车来了马上跳起然后一起大笑。这时她意识到离开Noah时自己似乎变回了那个no freedom的女孩。 \u003c!DOCTYPE html\u003e\r","permalink":"https://711lll711.github.io/posts/read/thenotebook/","summary":"关于主题 Freedom.What do you want?Noa","title":"恋恋笔记本"},{"content":"测试相册功能 \u003c!DOCTYPE html\u003e\rtest\r香克斯\r香克斯\r","permalink":"https://711lll711.github.io/posts/life/life/","summary":"测试相册功能 \u003c!DOCTYPE html\u003e test 香克斯 香克斯","title":"Life"},{"content":"\rKlutz\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r👉友链格式\r名称： Klutz\u0026rsquo;s Blog 网址： https://github.com/711lll711.github.io 图标： https://github.com/711lll711.github.io/img/avatar.png 描述： 一个记录技术、阅读、生活的博客 ","permalink":"https://711lll711.github.io/links/","summary":"Klutz\u0026#39;s Blog 一个记录技术、阅读、生活的","title":"🤝友链"}]